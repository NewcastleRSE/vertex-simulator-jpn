function[synapsesArrSim] =  runSimulationMultiregional(pS, connectionStacked, electrodeStacked,regionConnect)
%RUNSIMULATION Run the simulation given the model generated by initNetwork().
%   RUNSIMULATION(PARAMS, CONNECTIONS, ELECTRODES) runs the simulation
%   given the model generated by initNetwork(). PARAMS, CONNECTIONS and
%   ELECTRODES are the PARAMS, CONNECTIONS and ELECTRODES outputs from the
%   initNetwork() function. RUNSIMULATION automatically saves the simulation
%   results in the directory specified by the user in the recording
%   settings structure given to initNetwork().


% unstack the parameters for the different regions
ROI_N = length(pS);

%find delay steps for if distances have been included
propSpeed=120; %mm/ms
regionConnect.map
regionConnect.map=ceil(regionConnect.map./(propSpeed*pS{1}.SimulationSettings.timeStep));
regionConnect.map


% Create shorthand names for the parameter structures in params
% TP = params.TissueParams;
% NP = params.NeuronParams;
% CP = params.ConnectionParams;
% RS = params.RecordingSettings;
% SS = params.SimulationSettings;

% Get the directory to save files to (and create it if necessary)
outputDirectory = pS{1}.RecordingSettings.saveDir; %the saveDir should be the same for each region.
if ~strcmpi(outputDirectory(end), '/')
    outputDirectory = [outputDirectory '/'];
end
if exist(outputDirectory, 'dir') ~= 7
    mkdir(outputDirectory);
end

numSaves = 1;
nIntSize = 'uint32';
tIntSize = 'uint16';

% If loading spikes from a previous simulation, and spikeLoadDir is not
% specified in params.SimulationSettings, assume that we are loading spikes
% from the output directory

NeuronModelArr=cell(3,1);

for rn=1:ROI_N %loop for region number
    
    pS{rn}.RecordingSettings.saveDir = outputDirectory;
    if isfield(pS{rn}.SimulationSettings,'spikeLoad')
        if pS{rn}.SimulationSettings.spikeLoad
            if ~isfield(pS{rn}.SimulationSettings, 'spikeLoadDir')
                inputDirectory = outputDirectory;
                pS{rn}.SimulationSettings.spikeLoadDir = inputDirectory;
            end
        end
    end
    
    
    %NP = NeuronParams;
    % Calculate passive neuron properties in correct units
    pS{rn}.NeuronParams = calculatePassiveProperties(pS{rn}.NeuronParams, pS{rn}.TissueParams);
    
    
    % If using pre-calculated spike times with the loadspiketimes neuron model,
    % check the stored spike times can be found, then load them and convert
    % into units of timeStep
    loadedSpikeTimeCell{rn} = cell(pS{rn}.TissueParams.numGroups, 1);
    for iGroup = 1:pS{rn}.TissueParams.numGroups
        if strcmpi(pS{rn}.NeuronParams(iGroup).neuronModel, 'loadspiketimes')
            spkfile = pS{rn}.NeuronParams(iGroup).spikeTimeFile; % check spikeTimeDir is a field
            if exist(spkfile,'file') ~= 2
                errMsg = ['The specified spike time file for neuron group ' ...
                    num2str(iGroup) ' does not exist.'];
                error('vertex:runSimulation:spikeTimeDirError', errMsg);
            else
                loadedSpikeTimes = load(spkfile);
                fName = fields(loadedSpikeTimes);
                loadedSpikeTimeCell{iGroup} = loadedSpikeTimes.(fName{1});
                for ii = 1:length(loadedSpikeTimeCell{iGroup})
                    loadedSpikeTimeCell{iGroup}{ii} = ...
                        sort(round(loadedSpikeTimeCell{iGroup}{ii} ./ pS{rn}.SimulationSettings.timeStep));
                end
            end
        end
    end
    
    % Setup the neuron ID mapping for routing spikes, saving variables etc.
    [NeuronIDMap{rn}] = setupNeuronIDMapping(pS{rn}.TissueParams, pS{rn}.SimulationSettings);
    
    % Initialise the neuron models
    [NeuronModelArr{rn}] = ...
        setupNeuronDynamicVars(pS{rn}.TissueParams, pS{rn}.NeuronParams, pS{rn}.SimulationSettings, NeuronIDMap{rn}, loadedSpikeTimeCell);
end



for rn=1:ROI_N
    % Initialise the synapse models
    [SynapseModelArr{rn}, synMapCell{rn}] = setupSynapseDynamicVars(pS{rn}.TissueParams, pS{rn}.NeuronParams, pS{rn}.ConnectionParams, pS{rn}.SimulationSettings, pS{rn}.RecordingSettings);
    
    % Initialise the input models (if any)
    if isfield(pS{rn}.NeuronParams, 'Input')
        [InputModelArr{rn}] = setupInputDynamicVars(pS{rn}.TissueParams, pS{rn}.NeuronParams, pS{rn}.SimulationSettings);
    else
        InputModelArr{rn} = [];
    end
    
    
    
    % Prepare synapses and synaptic weights.
    [synapsesArrSim{rn}, weightArr{rn}] = prepareSynapsesAndWeights(pS{rn}.TissueParams,pS{rn}.ConnectionParams,pS{rn}.SimulationSettings,connectionStacked{rn});
    
    
    
    
    % Initialise the recording variables
    [pS{rn}.RecordingSettings, RecVar{rn}, lineSourceModCell{rn}] = ...
        setupRecordingVars(pS{rn}.TissueParams, pS{rn}.NeuronParams, pS{rn}.SimulationSettings, pS{rn}.RecordingSettings, NeuronIDMap{rn}, electrodeStacked{rn}, weightArr{rn},synapsesArrSim{rn});
    
    
    
    
    
    
    
    %% Setting the stimulation field v_ext for each neuron compartment
    %Get_V_ext returns the extracellular potential specified by
    %TP.StimulationsField at each of the compartment midpoints.
    %setVext is a function attached to the NeuronModel object.
    
    %It will assign the values passed to it to the v_ext field of the neuron.
    if isfield(pS{rn}.TissueParams, 'StimulationField')
        if pS{rn}.SimulationSettings.parallelSim
            compartments = pS{rn}.TissueParams.compartmentlocations;
            CurrentNMA=NeuronModelArr{rn};
            
            spmd
                subsetInLab = find(pS{rn}.SimulationSettings.neuronInLab==labindex());
                %NeuronModelArr{rn} = get_compartment_midpoints(pS{rn}.TissueParams,NeuronModelArr{rn}, pS{rn}.SimulationSettings,compartments);
                CurrentNMA = get_compartment_midpoints(pS{rn}.TissueParams,CurrentNMA, pS{rn}.SimulationSettings,compartments);
                
                
                if isa(pS{rn}.TissueParams.StimulationField,'pde.TimeDependentResults')
                    for iGroup = 1:length(NeuronModelArr{rn})
                        for iStimTime = 1:size(pS{rn}.TissueParams.StimulationField.NodalSolution,2)
                            paraStimParam(iGroup).V_ext_mat(:,:,iStimTime) = get_V_ext(NeuronModelArr{rn}{iGroup}.midpoints, pS{rn}.TissueParams.StimulationField,iStimTime);
                        end
                        setVext(NeuronModelArr{rn}{iGroup},paraStimParam(iGroup).V_ext_mat(:,:,1));
                    end
                    nsaves = 0;
                else
                    for iGroup = 1:length(NeuronModelArr{rn})
                        setVext(NeuronModelArr{rn}{iGroup},get_V_ext(NeuronModelArr{rn}{iGroup}.midpoints, pS{rn}.TissueParams.StimulationField,1));
                    end
                    if isfield(pS{rn}.TissueParams,'tRNS')
                        setVext(NeuronModelArr{rn}{iGroup},NeuronModelArr{rn}{iGroup}.v_ext*pS{rn}.TissueParams.tRNS);
                    end
                end
            end
            NeuronModelArr{rn}=CurrentNMA;
        else
            NeuronModelArr{rn} = get_compartment_midpoints(pS{rn}.TissueParams,NeuronModelArr{rn}, pS{rn}.SimulationSettings, pS{rn}.TissueParams.compartmentlocations);
            if isa(pS{rn}.TissueParams.StimulationField,'pde.TimeDependentResults')
                for iGroup = 1:length(NeuronModelArr{rn})
                    for iStimTime = 1:size(pS{rn}.TissueParams.StimulationField.NodalSolution,2)
                        pS{rn}.NeuronParams(iGroup).V_ext_mat(:,:,iStimTime) = get_V_ext(NeuronModelArr{rn}{iGroup}.midpoints, pS{rn}.TissueParams.StimulationField,iStimTime);
                    end
                    setVext(NeuronModelArr{rn}{iGroup},pS{rn}.NeuronParams(iGroup).V_ext_mat(:,:,1));
                end
            else
                for iGroup = 1:length(NeuronModelArr{rn})
                    setVext(NeuronModelArr{rn}{iGroup},get_V_ext(NeuronModelArr{rn}{iGroup}.midpoints, pS{rn}.TissueParams.StimulationField,1));
                    disp('stimulation field set')
                end
            end
        end
        
    end
    
    %% spike loading
    
    if isfield(pS{rn}.SimulationSettings,'spikeLoad')
        S{rn}.spikeLoad = pS{rn}.SimulationSettings.spikeLoad;
    else
        S{rn}.spikeLoad = false;
    end
    
    if S{rn}.spikeLoad
        inputDirectory = pS{rn}.SimulationSettings.spikeLoadDir;
        if ~strcmpi(inputDirectory(end), '/')
            inputDirectory = [inputDirectory '/'];
        end
        fName = sprintf('%sRecordings%d.mat', inputDirectory, numSaves);
        loadedSpikes = load(fName);
        iterator(rn).dataFieldName = fields(loadedSpikes);
    else
        loadedSpikes = [];
        
    end
    
    S{rn}.spikes = zeros(pS{rn}.TissueParams.N * pS{rn}.SimulationSettings.minDelaySteps, 1, nIntSize);
    S{rn}.spikeStep = zeros(pS{rn}.TissueParams.N * pS{rn}.SimulationSettings.minDelaySteps, 1, tIntSize);
    S{rn}.spikeCount = zeros(1, 1, nIntSize);
    
    iterator(rn).groupComparts = [pS{rn}.NeuronParams.numCompartments];
    
    iterator(rn).numInGroup = diff(pS{rn}.TissueParams.groupBoundaryIDArr);
    neuronInGroup{rn} = ...
        createGroupsFromBoundaries(pS{rn}.TissueParams.groupBoundaryIDArr);
    
    %% stdp
    
    %disp(['max: ' num2str(max(StimParams.activation))]);
    iterator(rn).stdp = false;
    for iPostGroup = 1:length(SynapseModelArr{rn}(:,1))
        for iSpkSynGroup = 1:length(SynapseModelArr{rn}(iPostGroup,:))
            if isa(SynapseModelArr{rn}{iPostGroup, iSpkSynGroup}, 'STDPModel')
                iterator(rn).stdp = true;
            end
        end
    end
    if iterator(rn).stdp
        disp('Using stdp, so calculating postsynaptic to presynaptic map');
        
        if pS{1}.SimulationSettings.parallelSim
            spmd
                posttoprearr = reverseSynArr(synapsesArrSim{rn});
                disp('Map calculated');
            end
            revSynArr = posttoprearr{1};
            for iLab = 1:length(posttoprearr)
                currLabSynArr = posttoprearr{iLab};
                revSynArr(~cellfun(@isempty,currLabSynArr(:,1)),1) = currLabSynArr(~cellfun(@isempty,currLabSynArr(:,1)),1);
                revSynArr(~cellfun(@isempty,currLabSynArr(:,2)),2) = currLabSynArr(~cellfun(@isempty,currLabSynArr(:,2)),2);
            end
        else
            revSynArr{rn} = reverseSynArr(synapsesArrSim{rn});
            disp('Map calculated');
        end
    else
        revSynArr{rn} = [];
    end
    
    
    
    %% vars to keep track of where we are in recording buffers:
    iterator(rn).recTimeCounter = 1;
    iterator(rn).sampleStepCounter = 1;
    iterator(rn).spikeRecCounter = 1;
    iterator(rn).comCount = pS{rn}.SimulationSettings.minDelaySteps;
    iterator(rn).numSaves = numSaves;
    iterator(rn).loadedSpikes = loadedSpikes;
    iterator(rn).bufferLength = pS{rn}.SimulationSettings.maxDelaySteps;
    iterator(rn).nsaves = 0;
    iterator(rn).weightsArrcount = 1;
    
    if isempty(regionConnect.dummyNeuronPops{rn})
        dummyNeuronIDs{rn} = [];
    else
        dummyNeuronIDs{rn} = find(neuronInGroup{rn}==regionConnect.dummyNeuronPops{rn});
    end
    if isempty(regionConnect.exportingNeuronPops{rn})
        exportingNeuronIDs{rn} =[];
    else
        exportingNeuronIDs{rn} = find(neuronInGroup{rn}==regionConnect.exportingNeuronPops{rn});
    end
    
end
clear rn


for rn= 1:ROI_N
    for rr = find(regionConnect.map(rn,:)) % for all regions recieving connections from the current region
        % check that the number of exporting neurons and dummy recieving regions
        % are the same, and if they aren't, adjust accordingly.
        if length(exportingNeuronIDs{rn})>length(dummyNeuronIDs{rr})
            fprintf('Size mismatch between exporting neurons and dummy neurons for connection from region %s to region %d \n', rn, rr)
            disp('More exporting neurons than dummy neurons, reducing the number of exporting neurons to fit the number of dummy neurons')
            exportingNeuronIDs{rn} = datasample(exportingNeuronIDs{rn},length(dummyNeuronIDs{rr}),'Replace',false);
        elseif length(exportingNeuronIDs{rn})<length(dummyNeuronIDs{rr})
            fprintf('Size mismatch between exporting neurons and dummy neurons for connection from region %s to region %d \n', rn, rr)
            disp('More dummy neurons than exporting neurons, reducing the number of dummy neurons passing signals to fit the number of exporting neurons')
            dummyNeuronIDs{rn} = datasample(dummyNeuronIDs{rn},length(exportingNeuronIDs{rn}),'Replace',false);
        end
        delayCounter{rn,rr}=1; %initialise counters for delays
        if regionConnect.map(rn,rr)<2
            delayAccess{rn,rr}=1; %if there is no delay set to 1
        else
            delayAccess{rn,rr}=2; %otherwise start at 2
        end
        exportingNeuronSpikes{rn}{rr}=zeros(length(exportingNeuronIDs{rn}),regionConnect.map(rn,rr));
        
    end
    pS{rn}.TissueParams.exportNeuronIDs = exportingNeuronIDs{rn};
    pS{rn}.TissueParams.dummyNeuronIDs = dummyNeuronIDs{rn};
    
end

clear rn rr

outputDirectory = pS{1}.RecordingSettings.saveDir;

stimcount = 1;
timeStimStep = 1;


simulationSteps = round(pS{1}.SimulationSettings.simulationTime / pS{1}.SimulationSettings.timeStep);






%% Simulation loop


for simStep = 1:simulationSteps
    
    for rgn = 1:ROI_N
        
        
        % now simulate for the current time step, dependent on parallel or
        % serial mode
        
        if pS{1}.SimulationSettings.parallelSim
            % IF IN PARALLEL MODE:
            
            % first establish the stimulation field, if there is one, as this is dependent on the current time value.
            if isfield(pS{rgn}.TissueParams, 'StimulationField')
                current_time = simStep * pS{rgn}.SimulationSettings.timeStep;
                
                if current_time > pS{rgn}.TissueParams.StimulationOn(stimcount) && current_time < pS{rgn}.TissueParams.StimulationOff(stimcount)
                    for iGroup = 1:pS{rgn}.TissueParams.numGroups
                        
                        if  ~NeuronModelArr{rgn}.incorporate_vext
                            stimulationOn(NeuronModelArr{rn}{iGroup});
                        end
                        % For time varying stimulation, step through the time
                        % dimension of the vext matrix for each simStep where
                        % stimulation is active. The vext matrix should have
                        % been previously interpolated in runSimulation.
                        if isa(pS{rgn}.TissueParams.StimulationField, 'pde.TimeDependentResults')
                            setVext(NeuronModelArr{rgn}{iGroup},pS{rgn}.NeuronParams(iGroup).V_ext_mat(:,:,timeStimStep));
                        elseif isfield(pS{rgn}.TissueParams, 'tRNS')
                            setVext(NeuronModelArr{rgn}{iGroup},NeuronModelArr{rgn}{iGroup}.v_ext*pS{rgn}.TissueParams.tRNS);
                        end
                        
                    end
                    if isfield(pS{rgn}.TissueParams, 'tRNS')
                        pS{rgn}.TissueParams.tRNS = wgn(1,1,0); % generate a new random number for tRNS.
                    end
                    timeStimStep = timeStimStep+1;
                    % reset timeStimStep if it gets passed the length of the
                    % time dimension in the stimulation field, this will loop
                    % back to the beginning of the time varying stimulation.
                    if timeStimStep > size(pS{rgn}.TissueParams.StimulationField.NodalSolution,2)
                        timeStimStep = 1;
                    end
                elseif current_time > pS{rgn}.TissueParams.StimulationOff(stimcount)
                    for iGroup = 1:pS{rgn}.TissueParams.numGroups
                       if  NeuronModelArr{rgn}{iGroup}.incorporate_vext
                            stimulationOff(NeuronModelArr{rgn}{iGroup});
                        end
                        if stimcount < length(pS{rgn}.TissueParams.StimulationOn)
                            stimcount = stimcount+1;
                        end
                    end
                end
            end
            
            
            
            
            [NeuronModelArr{rgn}, SynapseModelArr{rgn}, InputModelArr{rgn},S{rgn},RecVar{rgn},weightArr{rgn}] = simulateParallelMultiregion(pS{rgn}.TissueParams, pS{rgn}.NeuronParams, pS{rgn}.SimulationSettings, pS{rgn}.RecordingSettings, NeuronIDMap{rgn}, NeuronModelArr{rgn}, ...
                SynapseModelArr{rgn}, InputModelArr{rgn}, RecVar{rgn}, lineSourceModCell{rgn}, ...
                synapsesArrSim{rgn}, weightArr{rgn}, synMapCell{rgn}, iterator(rgn), simStep, S{rgn}, revSynArr{rgn}, neuronInGroup{rgn});
            
            if sum(regionConnect.map(rgn,:)>0) %check if the current region has an outbound connection and any spikes to send
                %update the spikes by putting these into the recieving region.
                nlab=pS{rgn}.SimulationSettings.neuronInLab;
                neuronIDs=1:length(nlab);
                currentSpikes = []; % initialise exporting neuron spikes
                for lb = 1:length(NeuronModelArr{rgn}) % for each lab
                    NMA_copy=NeuronModelArr{rgn}{lb}; % cloning the current region and lab neuron model to a placeholder so it can be accessed and edited
                    IDsinLab=neuronIDs(nlab==lb);
                    currentSpikes=[currentSpikes;
                        NMA_copy{regionConnect.exportingNeuronPops{rgn}}.spikes(ismember(IDsinLab,exportingNeuronIDs{rgn}))]; % find spikes from neurons which can export to the other region
                    %NB: the order of spikes here will be muddled up, but
                    %should be the same each time at least. The dummy
                    %neurons don't need an exact correspondence to the
                    %exporting neurons, but it should be a consistent
                    %correspondance.
                end
                clear lb
                for rr = find(regionConnect.map(rgn,:)) % for all regions recieving connections from the current region
                    nlab_rr=pS{rr}.SimulationSettings.neuronInLab;
                    neuronIDs=1:length(nlab_rr);
                    labDummyCount=1;
                    exportingNeuronSpikes{rgn}{rr}(:,delayCounter{rgn,rr})=currentSpikes;
                    for lb=1:length(NeuronModelArr{rgn})
                        NMA_rr = NeuronModelArr{rr}{lb}; % cloning the connected region and lab neuron model to a placeholder so it can be accessed and edited
                        IDsinLab=neuronIDs(nlab_rr==lb);
                        numDummyNeuronsInLab=sum(ismember(dummyNeuronIDs{rr},IDsinLab));
                        assignSpikes(NMA_rr{regionConnect.dummyNeuronPops{rr}},exportingNeuronSpikes{rgn}{rr}(labDummyCount:labDummyCount+numDummyNeuronsInLab-1,delayAccess{rgn,rr}));
                        labDummyCount=labDummyCount+numDummyNeuronsInLab;
                        NeuronModelArr{rgn}{lb}=NMA_rr;
                        % NB: the assignSpikes method is unique to passive
                        % neurons, so the dummy neurons must have passive
                        % dynamics for this to work.
                        
                    end
                    
                    delayAccess{rgn,rr}=delayAccess{rgn,rr}+1;
                    delayCounter{rgn,rr}=delayCounter{rgn,rr}+1;
                    if delayCounter{rgn,rr}>regionConnect.map(rgn,rr)
                        delayCounter{rgn,rr}=1; %reset
                    end
                    if delayAccess{rgn,rr}>regionConnect.map(rgn,rr)
                        delayAccess{rgn,rr}=1;
                    end
                    
                    clear lb
                end
            end
            clear currentSpikes
            
            
        else
            % IF IN SERIAL MODE:
            
            
            % first establish the stimulation field, if there is one, as this is dependent on the current time value.
            if isfield(pS{rgn}.TissueParams, 'StimulationField')
                current_time = simStep * pS{rgn}.SimulationSettings.timeStep;
                
                if current_time > pS{rgn}.TissueParams.StimulationOn(stimcount) && current_time < pS{rgn}.TissueParams.StimulationOff(stimcount)
                    for iGroup = 1:pS{rgn}.TissueParams.numGroups
                        if  ~NeuronModelArr{rgn}{iGroup}.incorporate_vext
                            stimulationOn(NeuronModelArr{rgn}{iGroup});
                        end
                        % For time varying stimulation, step through the time
                        % dimension of the vext matrix for each simStep where
                        % stimulation is active. The vext matrix should have
                        % been previously interpolated in runSimulation.
                        if isa(pS{rgn}.TissueParams.StimulationField, 'pde.TimeDependentResults')
                            setVext(NeuronModelArr{rgn}{iGroup},pS{rgn}.NeuronParams(iGroup).V_ext_mat(:,:,timeStimStep));
                        elseif isfield(pS{rgn}.TissueParams, 'tRNS')
                            setVext(NeuronModelArr{rgn}{iGroup},NeuronModelArr{rgn}{iGroup}.v_ext*pS{rgn}.TissueParams.tRNS);
                        end
                        
                    end
                    if isfield(pS{rgn}.TissueParams, 'tRNS')
                        pS{rgn}.TissueParams.tRNS = wgn(1,1,0); % generate a new random number for tRNS.
                    end
                    timeStimStep = timeStimStep+1;
                    % reset timeStimStep if it gets passed the length of the
                    % time dimension in the stimulation field, this will loop
                    % back to the beginning of the time varying stimulation.
                    if timeStimStep > size(pS{rgn}.TissueParams.StimulationField.NodalSolution,2)
                        timeStimStep = 1;
                    end
                elseif current_time > pS{rgn}.TissueParams.StimulationOff(stimcount)
                    for iGroup = 1:pS{rgn}.TissueParams.numGroups
                        if  NeuronModelArr{rgn}{iGroup}.incorporate_vext
                            stimulationOff(NeuronModelArr{rgn}{iGroup});
                        end
                        if stimcount < length(pS{rgn}.TissueParams.StimulationOn)
                            stimcount = stimcount+1;
                        end
                    end
                end
            end
            
            
            
            [NeuronModelArr{rgn}, SynapseModelArr{rgn}, InputModelArr{rgn}, iterator(rgn),S{rgn},RecVar{rgn},weightArr{rgn}] = simulateMultiregional(pS{rgn}.TissueParams, pS{rgn}.NeuronParams, pS{rgn}.SimulationSettings,...
                pS{rgn}.RecordingSettings, S{rgn}, iterator(rgn), simStep, revSynArr{rgn}, NeuronIDMap{rgn}, NeuronModelArr{rgn}, ...
                SynapseModelArr{rgn}, InputModelArr{rgn}, RecVar{rgn}, neuronInGroup{rgn}, lineSourceModCell{rgn}, ...
                synapsesArrSim{rgn}, weightArr{rgn}, synMapCell{rgn},rgn);
            
            %now need to check for incoming spikes for the next region and
            %feed these in by modifying the S parameter? To make this
            %extendible I will need some kind of matrix to hold which
            %regions connect to which other regions, and then only send
            %spikes to the recieving regions.
            if sum(regionConnect.map(rgn,:)>0) %check if the current region has an outbound connection
                %update the spikes by putting these into the recieving region.
                
                currentSpikes=NeuronModelArr{rgn}{regionConnect.exportingNeuronPops{rgn}}.spikes(exportingNeuronIDs{rgn}); % find spikes from neurons which can export to the other region
                
                for rr = find(regionConnect.map(rgn,:)) % for all regions recieving connections from the current region
                    exportingNeuronSpikes{rgn}{rr}(:,delayCounter{rgn,rr})=currentSpikes;
                    
                    if ~isempty(regionConnect.dummyNeuronPops{rr}) % don't bother assigning spikes unless there are some to assign!
                            assignSpikes(NeuronModelArr{rr}{regionConnect.dummyNeuronPops{rr}},exportingNeuronSpikes{rgn}{rr}(:,delayAccess{rgn,rr}));
                    end
                        % do I need an else assign spikes to zero?
                    %end
                    % NB: the assignSpikes method is unique to passive
                    % neurons, so the dummy neurons must have passive
                    % dynamics for this to work.
                    
                    delayAccess{rgn,rr}=delayAccess{rgn,rr}+1;
                    delayCounter{rgn,rr}=delayCounter{rgn,rr}+1;
                    if delayCounter{rgn,rr}>regionConnect.map(rgn,rr)
                        delayCounter{rgn,rr}=1; %reset
                    end
                    if delayAccess{rgn,rr}>regionConnect.map(rgn,rr)
                        delayAccess{rgn,rr}=1;
                    end
                end
            end
        end
        
        
        
    end
end



if isfield(pS{1}.RecordingSettings,'LFPoffline') && pS{1}.RecordingSettings.LFPoffline
    save(outputDirectory, 'LineSourceConsts.mat', lineSourceModCell);
end


% Store the parameters in the same folder, so we can reference them later
% during analysis (used by loadResults, as well as useful for tracking
% simulations). You may want to copy these lines to store each parameter
% set after every time you call simulate()/simulateParallel().
parameterCell = {pS,SynapseModelArr};
fname = [outputDirectory 'parameters.mat'];
save(fname, 'parameterCell','-v7.3'); % saving in version 7.3 to avoid errors from large files.